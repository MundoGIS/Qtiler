<!--
  This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
  If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
  Copyright (C) 2025 MundoGIS.
-->
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Qtiler · Tile viewer</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="/styles.css">
    <!-- Usar CDN jsdelivr con SRI correcto (coincide con contenido servido) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous"/>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
    <!-- Proj4Leaflet (para CRS distintos a EPSG:3857) -->
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.1/dist/proj4.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4leaflet@1.0.2/src/proj4leaflet.min.js" crossorigin="anonymous"></script>
    <style>
      html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--app-bg,#0f172a)}
      .viewer-shell{display:flex;flex-direction:column;min-height:100vh;background:var(--app-bg,#0f172a);color:var(--text,#e2e8f0)}
      .viewer-main{flex:1;display:flex;flex-direction:column;padding:16px}
      .viewer-map-wrap{flex:1;position:relative;border:1px solid var(--border,#1e293b);border-radius:16px;overflow:hidden;background:#0b1220}
      #map{position:absolute;inset:0}
      .info{position:absolute;top:12px;left:12px;background:rgba(15,23,42,.6);color:#f8fafc;padding:10px 14px;border-radius:10px;font-size:12px;backdrop-filter:blur(6px);max-width:320px}
      .info code{font-size:11px;word-break:break-all}
      @media (max-width:768px){
        .viewer-main{padding:12px}
        .viewer-map-wrap{border-radius:12px}
        .info{max-width:260px}
      }
    </style>
  </head>
  <body>
    <div class="viewer-shell">
      <header class="app-header viewer-header">
        <div class="header-inner">
          <div class="brand">
            <a href="/index.html" class="brand-logo">Qtiler</a>
            <span class="brand-tagline">Tile viewer</span>
          </div>
          <nav class="main-nav" aria-label="Secondary">
            <a href="/index.html" class="nav-link">Dashboard</a>
            <a href="/guide.html" class="nav-link" target="_blank" rel="noopener">Guide</a>
          </nav>
        </div>
      </header>
      <main class="viewer-main">
        <div class="viewer-map-wrap">
          <div id="map"></div>
          <div class="info" id="info">Cargando…</div>
        </div>
      </main>
      <footer class="app-footer viewer-footer">
        <div class="footer-inner">
          <div class="footer-brand">© <span id="viewer_footer_year"></span> MundoGIS</div>
          <div class="footer-links">
            <a href="https://mundogis.se" target="_blank" rel="noopener">mundogis.se</a>
            <a href="mailto:info@mundogis.se">info@mundogis.se</a>
          </div>
        </div>
      </footer>
    </div>
    <script>
      const footerYearEl = document.getElementById('viewer_footer_year');
      if (footerYearEl) footerYearEl.textContent = String(new Date().getFullYear());

    const params = new URLSearchParams(location.search);
  const layer = params.get('layer');
  const theme = params.get('theme');
  const project = params.get('project');
  const modeParam = params.get('mode');
  const displayMode = modeParam === 'remote' ? 'remote' : (modeParam === 'cache' ? 'cache' : 'comparison');
  const showCache = displayMode !== 'remote';
  const showRemote = displayMode !== 'cache';
      const infoEl = document.getElementById('info');
  if(!layer && !theme){ infoEl.textContent = 'Falta parámetro layer o theme'; }
  if(!project){ infoEl.textContent = 'Falta parámetro project'; }
  const tileTemplate = theme
    ? `/wmts/${encodeURIComponent(project)}/themes/${encodeURIComponent(theme)}/{z}/{x}/{y}.png`
    : `/wmts/${encodeURIComponent(project)}/${encodeURIComponent(layer)}/{z}/{x}/{y}.png`;

      // Extent y CRS (opcional): intentar leer index.json para centrar
      async function getLayerContext(){
        if (!project) return null;
        let cacheEntry = null;
        try {
          const r = await fetch('/cache/' + encodeURIComponent(project) + '/index.json');
          if (r.ok) {
            const j = await r.json();
            cacheEntry = (j.layers || []).find(l => {
              if (!l || !l.name) return false;
              const kind = l.kind || (l.theme ? 'theme' : 'layer');
              if (theme) return kind === 'theme' && l.name === theme;
              return kind !== 'theme' && l.name === layer;
            }) || null;
          }
        } catch {}

        let layerEntry = null;
        let themeEntry = null;
        try {
          const res = await fetch('/projects/' + encodeURIComponent(project) + '/layers');
          if (res.ok) {
            const payload = await res.json();
            if (Array.isArray(payload.layers)) {
              layerEntry = payload.layers.find(item => item && item.name === layer) || null;
            }
            if (Array.isArray(payload.themes)) {
              themeEntry = payload.themes.find(item => item && item.name === theme) || null;
            }
          }
        } catch {}

        const combined = cacheEntry || layerEntry || themeEntry ? {
          ...(layerEntry || {}),
          ...(cacheEntry || {}),
          ...(themeEntry || {})
        } : null;

        return { cacheEntry, layerEntry, themeEntry, combined };
      }

      (async () => {
        const metaContext = await getLayerContext();
        const cacheMeta = metaContext?.cacheEntry || null;
        const layerMeta = metaContext?.layerEntry || null;
        const themeMeta = metaContext?.themeEntry || null;
        const meta = metaContext?.combined || null;
        const crsInfo = meta ?
          `<div>Zooms: ${meta.zoom_min != null ? meta.zoom_min : '?'} - ${meta.zoom_max != null ? meta.zoom_max : '?'}</div>`+
          `<div>Tiles: ${meta.tile_count != null ? meta.tile_count : '?'} | Layer CRS: ${meta.crs || 'n/a'}${meta.tile_crs ? ` | Tiles CRS: ${meta.tile_crs}` : ''}</div>`
          : '<div>Metadata unavailable</div>';

        const modeLabel = displayMode === 'remote'
          ? 'Remoto'
          : (displayMode === 'cache' ? 'Cacheado' : 'Comparación');
        infoEl.innerHTML = `<div style="font-weight:600">Proyecto: ${project||'(?)'}</div>`+
          (theme ? `<div>Theme: ${theme}</div>` : `<div>Layer: ${layer||'(?)'}</div>`)+
          `<div>Modo: ${modeLabel}</div>`+
          `<div>Template: <code>${tileTemplate.replace('{z}','{z}')}</code></div>`+
          crsInfo;
        if (!cacheMeta && showCache) {
          infoEl.innerHTML += '<div style="margin-top:6px;color:#fbbf24">No cached tiles detected.</div>';
        }

        if (typeof L === 'undefined') {
          infoEl.innerHTML += '<div style="color:#f66">Leaflet no cargó (revisa bloqueo de SRI o CSP)</div>';
          return;
        }

        const mapOptions = {
          preferCanvas: true,
          zoomControl: true
        };
        if (meta) {
          if (Number.isFinite(meta.zoom_min)) mapOptions.minZoom = meta.zoom_min;
          if (Number.isFinite(meta.zoom_max)) {
            mapOptions.maxZoom = Math.min(meta.zoom_max + 6, 23);
          }
        }

        const projDefinitions = {
          'EPSG:3006': '+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0 +units=m +no_defs'
        };

  let crs = null;
  let extentLatLngBounds = null;
        const targetTileCrs = (meta && meta.tile_crs) ? meta.tile_crs : (layerMeta && layerMeta.crs ? layerMeta.crs : null);
        const hasCustomCrs = targetTileCrs && targetTileCrs !== 'EPSG:3857';
        if (hasCustomCrs && typeof proj4 !== 'undefined' && typeof L.Proj !== 'undefined') {
          let def = projDefinitions[targetTileCrs] || null;
          if (!def && typeof proj4.defs === 'function') {
            const existing = proj4.defs(targetTileCrs);
            if (existing) def = existing;
          }
          if (def && meta && meta.tile_matrix_set && meta.tile_matrix_set.top_left_corner && Array.isArray(meta.tile_matrix_set.matrices)) {
            const origin = meta.tile_matrix_set.top_left_corner;
            const matrices = Array.isArray(meta.tile_matrix_set.matrices) ? meta.tile_matrix_set.matrices : [];
            if (!Array.isArray(origin) || origin.length !== 2 || matrices.length === 0) {
              infoEl.innerHTML += '<div style="color:#ff9">Tile matrix metadata incompleta; usando EPSG:3857 por defecto.</div>';
            } else {
              const matrixZooms = matrices
                .map(m => (m && typeof m.z === 'number') ? m.z : null)
                .filter(z => Number.isFinite(z));
              const highestZoom = Number.isFinite(meta.zoom_max)
                ? meta.zoom_max
                : (matrixZooms.length ? Math.max(...matrixZooms) : (Number.isFinite(meta.zoom_min) ? meta.zoom_min : 0));
              const lowestZoom = Number.isFinite(meta.zoom_min)
                ? meta.zoom_min
                : (matrixZooms.length ? Math.min(...matrixZooms) : 0);
              const resolutions = new Array(Math.max(highestZoom, lowestZoom) + 1).fill(null);
              const matricesByZoom = new Map();
              matrices.forEach(m => {
                if (typeof m?.z !== 'number') return;
                matricesByZoom.set(m.z, m);
                let r = null;
                if (Number.isFinite(m.resolution)) {
                  r = m.resolution;
                } else if (Number.isFinite(m.scale_denominator)) {
                  r = m.scale_denominator * 0.00028;
                }
                if (Number.isFinite(r)) {
                  resolutions[m.z] = r;
                }
              });
              for (let z = resolutions.length - 2; z >= 0; z--) {
                if (!Number.isFinite(resolutions[z]) && Number.isFinite(resolutions[z + 1])) {
                  resolutions[z] = resolutions[z + 1] * 2;
                }
              }
              for (let z = 1; z < resolutions.length; z++) {
                if (!Number.isFinite(resolutions[z]) && Number.isFinite(resolutions[z - 1])) {
                  resolutions[z] = resolutions[z - 1] / 2;
                }
              }
              const filteredResolutions = resolutions.map(r => Number.isFinite(r) ? r : null);
              const tileWidth = meta.tile_matrix_set.tile_width || 256;
              const tileHeight = meta.tile_matrix_set.tile_height || 256;
              const originX = origin[0];
              const originY = origin[1];
              const referenceMatrix = matricesByZoom.get(highestZoom) || matrices[matrices.length - 1];
              const spanX = (referenceMatrix?.matrix_width || 1) * tileWidth * (referenceMatrix?.resolution || filteredResolutions[highestZoom] || 1);
              const spanY = (referenceMatrix?.matrix_height || 1) * tileHeight * (referenceMatrix?.resolution || filteredResolutions[highestZoom] || 1);
              const minx = originX;
              const maxx = originX + spanX;
              const maxy = originY;
              const miny = originY - spanY;
              const projectedBounds = L.bounds(L.point(minx, miny), L.point(maxx, maxy));
              const crsOptions = {
                resolutions: filteredResolutions,
                origin: [originX, originY],
                bounds: projectedBounds
              };
              crs = new L.Proj.CRS(targetTileCrs, def, crsOptions);
              mapOptions.crs = crs;
              try {
                const sw = crs.unproject(L.point(minx, miny));
                const ne = crs.unproject(L.point(maxx, maxy));
                extentLatLngBounds = L.latLngBounds(sw, ne);
              } catch (err) {
                extentLatLngBounds = null;
              }
              infoEl.innerHTML += `<div style="margin-top:6px;color:#dff">CRS personalizado (${targetTileCrs}) – rejilla WMTS local alineada.</div>`;
            }
          } else if (def && meta && meta.extent && meta.extent.length === 4) {
            const matrices = (meta.tile_matrix_set && Array.isArray(meta.tile_matrix_set.matrices)) ? meta.tile_matrix_set.matrices : [];
            const matrixZooms = matrices
              .map(m => (m && typeof m.z === 'number') ? m.z : null)
              .filter(z => Number.isFinite(z));
            const highestZoom = Number.isFinite(meta.zoom_max)
              ? meta.zoom_max
              : (matrixZooms.length ? Math.max(...matrixZooms) : (Number.isFinite(meta.zoom_min) ? meta.zoom_min : 0));
            const resolutions = new Array(Math.max(0, highestZoom) + 1).fill(null);
            matrices.forEach(m => {
              if (typeof m?.z !== 'number') return;
              let r = null;
              if (Number.isFinite(m.resolution)) {
                r = m.resolution;
              } else if (Number.isFinite(m.scale_denominator)) {
                r = m.scale_denominator * 0.00028;
              }
              if (Number.isFinite(r)) {
                resolutions[m.z] = r;
              }
            });
            // Rellenar resoluciones faltantes para mantener continuidad
            for (let z = resolutions.length - 2; z >= 0; z--) {
              if (!Number.isFinite(resolutions[z]) && Number.isFinite(resolutions[z + 1])) {
                resolutions[z] = resolutions[z + 1] * 2;
              }
            }
            for (let z = 1; z < resolutions.length; z++) {
              if (!Number.isFinite(resolutions[z]) && Number.isFinite(resolutions[z - 1])) {
                resolutions[z] = resolutions[z - 1] / 2;
              }
            }

            const origin = (meta.tile_matrix_set && Array.isArray(meta.tile_matrix_set.top_left_corner)) ? meta.tile_matrix_set.top_left_corner : null;
            const [minx, miny, maxx, maxy] = meta.extent;
            const crsOptions = {
              resolutions: resolutions,
              origin: origin && origin.length === 2 ? origin : [minx, maxy]
            };
            const projectedBounds = L.bounds(L.point(minx, miny), L.point(maxx, maxy));
            crsOptions.bounds = projectedBounds;
            crs = new L.Proj.CRS(targetTileCrs, def, crsOptions);
            mapOptions.crs = crs;

            try {
              const sw = crs.unproject(L.point(projectedBounds.min.x, projectedBounds.min.y));
              const ne = crs.unproject(L.point(projectedBounds.max.x, projectedBounds.max.y));
              extentLatLngBounds = L.latLngBounds(sw, ne);
            } catch (err) {
              extentLatLngBounds = null;
            }
            infoEl.innerHTML += `<div style="margin-top:6px;color:#dff">CRS personalizado (${targetTileCrs}) – rejilla WMTS local alineada.</div>`;
          } else {
            infoEl.innerHTML += '<div style="color:#ff9">No se definió Proj4 para este CRS; usando EPSG:3857 por defecto.</div>';
          }
        }

        const map = L.map('map', mapOptions);

        if (extentLatLngBounds) {
          map.fitBounds(extentLatLngBounds);
          try {
            map.setMaxBounds(extentLatLngBounds.pad(0.05));
          } catch (err) {
            map.setMaxBounds(extentLatLngBounds);
          }
        } else if (meta && Array.isArray(meta.extent_wgs84)) {
          const [eminx, eminy, emaxx, emaxy] = meta.extent_wgs84;
          map.fitBounds([[eminy, eminx], [emaxy, emaxx]]);
        } else if (meta && meta.extent && meta.extent.length === 4) {
          const [minx, miny, maxx, maxy] = meta.extent;
          map.setView([(miny + maxy) / 2, (minx + maxx) / 2], meta.zoom_min || 0);
        } else {
          map.setView([0, 0], meta ? meta.zoom_min || 0 : 0);
        }

        const layerOptions = {
          maxZoom: meta ? meta.zoom_max : 6,
          minZoom: meta ? meta.zoom_min : 0,
          maxNativeZoom: meta ? meta.zoom_max : undefined,
          minNativeZoom: meta ? meta.zoom_min : undefined,
          tileSize: 256,
          errorTileUrl: '',
          attribution: 'Local cache',
          noWrap: true,
          keepBuffer: 0
        };
        if (extentLatLngBounds) {
          layerOptions.bounds = extentLatLngBounds;
        }
        if (!crs) {
          layerOptions.detectRetina = false;
        }
        const remoteSource = !theme && layerMeta && layerMeta.remote_source ? layerMeta.remote_source : null;
        let remoteLayer = null;
        const remoteEnabled = showRemote && remoteSource;
        if (remoteEnabled) {
          if (remoteSource.type === 'wms' && remoteSource.url && remoteSource.layers) {
            const wmsOptions = {
              layers: remoteSource.layers,
              format: remoteSource.format || 'image/png',
              transparent: remoteSource.transparent !== false,
              version: remoteSource.version || '1.3.0',
              attribution: remoteSource.attribution || 'Remote WMS'
            };
            if (remoteSource.styles) wmsOptions.styles = remoteSource.styles;
            const declaredRemoteCrs = typeof remoteSource.crs === 'string' ? remoteSource.crs.trim().toUpperCase() : null;
            const mapCrs = map.options && map.options.crs ? map.options.crs : L.CRS.EPSG3857;
            const mapCrsCode = mapCrs && typeof mapCrs.code === 'string' ? mapCrs.code.toUpperCase() : null;
            const hasProjWms = typeof L !== 'undefined' && L.Proj && L.Proj.TileLayer && L.Proj.TileLayer.WMS;
            const useProjWms = !!hasProjWms && !!declaredRemoteCrs && mapCrsCode === declaredRemoteCrs;
            if (declaredRemoteCrs === 'EPSG:4326') {
              wmsOptions.crs = L.CRS.EPSG4326;
            } else if (declaredRemoteCrs === 'EPSG:3857') {
              wmsOptions.crs = L.CRS.EPSG3857;
            } else if (declaredRemoteCrs && mapCrsCode === declaredRemoteCrs) {
              wmsOptions.crs = mapCrs;
            }
            if (useProjWms) {
              // Use proj4leaflet WMS helper to respect axis order for projected CRSs.
              wmsOptions.uppercase = true;
              remoteLayer = new L.Proj.TileLayer.WMS(remoteSource.url, wmsOptions);
            } else {
              remoteLayer = L.tileLayer.wms(remoteSource.url, wmsOptions);
            }
          } else if (remoteSource.type === 'xyz' && remoteSource.url_template) {
            remoteLayer = L.tileLayer(remoteSource.url_template, {
              attribution: remoteSource.attribution || 'Remote XYZ',
              maxZoom: remoteSource.max_zoom || 20,
              subdomains: remoteSource.subdomains || 'abc'
            });
          }
        }

        if (remoteLayer) {
          remoteLayer.addTo(map);
        }

        let tiles = null;
        const cacheEnabled = showCache && cacheMeta;
        if (cacheEnabled) {
          const matricesByZoom = new Map();
          if (meta && meta.tile_matrix_set && Array.isArray(meta.tile_matrix_set.matrices)) {
            meta.tile_matrix_set.matrices.forEach(m => {
              if (m && typeof m.z === 'number') matricesByZoom.set(m.z, m);
            });
          }
          const layerOptionsFinal = {
            ...layerOptions,
            noWrap: true,
            bounds: extentLatLngBounds || layerOptions.bounds
          };
          const CustomTileLayer = L.TileLayer.extend({
            getTileUrl(coords) {
              const matrix = matricesByZoom.get(coords.z);
              if (!matrix) {
                return L.TileLayer.prototype.getTileUrl.call(this, coords);
              }
              const maxX = typeof matrix.matrix_width === 'number' ? matrix.matrix_width - 1 : Number.POSITIVE_INFINITY;
              const maxY = typeof matrix.matrix_height === 'number' ? matrix.matrix_height - 1 : Number.POSITIVE_INFINITY;
              if (coords.x < 0 || coords.y < 0 || coords.x > maxX || coords.y > maxY) {
                return L.Util.emptyImageUrl;
              }
              return tileTemplate
                .replace('{z}', coords.z)
                .replace('{x}', coords.x)
                .replace('{y}', coords.y);
            }
          });
          tiles = new CustomTileLayer(tileTemplate, layerOptionsFinal);
          tiles.addTo(map);
        }

  L.control.scale({ metric: true, imperial: false, position: 'bottomleft' }).addTo(map);

        if (meta && meta.scheme && meta.scheme !== 'xyz') {
          infoEl.innerHTML += '<div style="margin-top:6px;color:#cad">Esquema "'+meta.scheme+'" (WMTS local) – la vista usa la matriz declarada para alinear las teselas.</div>';
        }
        if (displayMode === 'remote') {
          if (remoteSource) {
            infoEl.innerHTML += '<div style="margin-top:6px;color:#bbf7d0">Remote source activo: '+remoteSource.type.toUpperCase()+'</div>';
          } else {
            infoEl.innerHTML += '<div style="margin-top:6px;color:#f87171">Modo remoto seleccionado pero no hay fuente remota disponible.</div>';
          }
        } else if (displayMode === 'cache') {
          if (!cacheMeta) {
            infoEl.innerHTML += '<div style="margin-top:6px;color:#f87171">Modo cache seleccionado pero no hay teselas cacheadas.</div>';
          } else {
            infoEl.innerHTML += '<div style="margin-top:6px;color:#bbf7d0">Mostrando solo teselas cacheadas.</div>';
          }
        } else if (remoteSource && cacheMeta) {
          infoEl.innerHTML += '<div style="margin-top:6px;color:#bbf7d0">Comparación: tiles cacheadas sobre la fuente remota.</div>';
        } else if (remoteSource && !cacheMeta && showRemote) {
          infoEl.innerHTML += '<div style="margin-top:6px;color:#bbf7d0">Fuente remota mostrada al no existir cache.</div>';
        }
      })();
    </script>
  </body>
</html>